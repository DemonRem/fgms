Only in C:\fgcvs\fgms-0-x: .git
Only in C:\Projects\fgms2\fgms-0-x: msvc
diff -ur C:\fgcvs\fgms-0-x\src\plib\netSocket.cxx C:\Projects\fgms2\fgms-0-x\src\plib\netSocket.cxx
--- C:\fgcvs\fgms-0-x\src\plib\netSocket.cxx	Mon Jan 31 18:54:49 2011
+++ C:\Projects\fgms2\fgms-0-x\src\plib\netSocket.cxx	Sun Aug 14 15:40:54 2011
@@ -42,7 +42,8 @@
 
 #else
 
-#include <winsock.h>
+#include <iostream>
+#include <winsock2.h>
 #include <stdarg.h>
 
 #endif
@@ -95,7 +96,11 @@
       }
       else
       {
+#ifdef _MSC_VER
+        printf( "netAddress::set to INADDR_ANY\n" );
+#else
         herror ( "netAddress::set" ) ;
+#endif
         sin_addr = INADDR_ANY ;
       }
     }
@@ -393,13 +398,13 @@
   if ( wsa_errno != 0 )
   {
     WSASetLastError(0);
-    ulSetError(UL_WARNING,"WSAGetLastError() => %d",wsa_errno);
     switch (wsa_errno) {
     case WSAEWOULDBLOCK: // always == NET_EAGAIN?
     case WSAEALREADY:
     case WSAEINPROGRESS:
       return true;
     }
+    printf("WARNING: WSAGetLastError() = %d",wsa_errno);
   }
   return false;
 #endif
@@ -542,7 +547,7 @@
 	WSADATA wsaData;
 
 	if ( WSAStartup(version_wanted, &wsaData) != 0 ) {
-		ulSetError(UL_WARNING,"Couldn't initialize Winsock 1.1");
+		printf("Couldn't initialize Winsock 1.1\n");
 		return(-1);
 	}
 #endif
diff -ur C:\fgcvs\fgms-0-x\src\server\common.h C:\Projects\fgms2\fgms-0-x\src\server\common.h
--- C:\fgcvs\fgms-0-x\src\server\common.h	Mon Jan 31 18:54:49 2011
+++ C:\Projects\fgms2\fgms-0-x\src\server\common.h	Fri Aug 12 18:46:14 2011
@@ -2,10 +2,11 @@
 #define __common_h
 
 #ifdef HAVE_CONFIG_H
-#       include <config.h>
+#include "config.h"
 #endif
-#include "error.h"
 
+#ifndef _MSC_VER
+#include "error.h"
 #include <sys/time.h>
 #include <sys/types.h>
 #include <sys/socket.h>
@@ -28,6 +29,7 @@
 #include <unistd.h>
 #include <sys/ipc.h>
 #include <sys/msg.h>
+#endif // !_MSC_VER
 
 
 #ifdef HAVE_SYS_SELECT_H
diff -ur C:\fgcvs\fgms-0-x\src\server\daemon.cxx C:\Projects\fgms2\fgms-0-x\src\server\daemon.cxx
--- C:\fgcvs\fgms-0-x\src\server\daemon.cxx	Mon Jan 31 18:54:49 2011
+++ C:\Projects\fgms2\fgms-0-x\src\server\daemon.cxx	Fri Aug 12 18:37:13 2011
@@ -22,7 +22,7 @@
 // to become a daemon
 //
 //////////////////////////////////////////////////////////////////////
-
+#ifndef _MSC_VER
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/wait.h>
@@ -231,5 +231,6 @@
 {
   // KillAllChildren ();
 }
+#endif // !_MSC_VER
 
 // vim: ts=2:sw=2:sts=0
diff -ur C:\fgcvs\fgms-0-x\src\server\daemon.hxx C:\Projects\fgms2\fgms-0-x\src\server\daemon.hxx
--- C:\fgcvs\fgms-0-x\src\server\daemon.hxx	Mon Jan 31 18:54:49 2011
+++ C:\Projects\fgms2\fgms-0-x\src\server\daemon.hxx	Fri Aug 12 18:47:21 2011
@@ -25,14 +25,15 @@
 #ifndef CDAEMON_HDR
 #define CDAEMON_HDR
 
-using namespace std;
-
+#ifndef _MSC_VER
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/signal.h>
 #include <list>
 #include <fcntl.h>
 
+using namespace std;
+
 class cDaemon
 {
   static pid_t PidOfDaemon;       // remember who we are
@@ -48,6 +49,10 @@
   static int  NumChildren ();
   static int  GetPid() { return PidOfDaemon; };
 };
+
+#endif // #ifndef _MSC_VER
+
+
 #endif
 
 // vim: ts=2:sw=2:sts=0
diff -ur C:\fgcvs\fgms-0-x\src\server\fg_geometry.cxx C:\Projects\fgms2\fgms-0-x\src\server\fg_geometry.cxx
--- C:\fgcvs\fgms-0-x\src\server\fg_geometry.cxx	Mon Jan 31 18:54:49 2011
+++ C:\Projects\fgms2\fgms-0-x\src\server\fg_geometry.cxx	Sat Aug 13 15:39:56 2011
@@ -22,7 +22,9 @@
 //////////////////////////////////////////////////////////////////////
 
 #include <math.h>
+#ifndef _MSC_VER
 #include <strings.h>
+#endif // _MSC_VER
 #include <assert.h>
 #include "fg_geometry.hxx"
 
@@ -342,7 +344,7 @@
   Point3D P;
 
   P = P1 - P2;
-  return (P.length() / SG_NM_TO_METER);
+  return (float)(P.length() / SG_NM_TO_METER);
 } // Distance ( const Point3D & P1, const Point3D & P2 )
 //////////////////////////////////////////////////////////////////////
 
diff -ur C:\fgcvs\fgms-0-x\src\server\fg_geometry.hxx C:\Projects\fgms2\fgms-0-x\src\server\fg_geometry.hxx
--- C:\fgcvs\fgms-0-x\src\server\fg_geometry.hxx	Mon Jan 31 18:54:49 2011
+++ C:\Projects\fgms2\fgms-0-x\src\server\fg_geometry.hxx	Fri Aug 12 18:47:55 2011
@@ -21,7 +21,7 @@
 //
 //////////////////////////////////////////////////////////////////////
 
-#if not defined FG_GEOMETRY_H
+#if !defined FG_GEOMETRY_H
 #define FG_GEOMETRY_H
 
 #include <simgear/math/SGMath.hxx>
diff -ur C:\fgcvs\fgms-0-x\src\server\fg_server.cxx C:\Projects\fgms2\fgms-0-x\src\server\fg_server.cxx
--- C:\fgcvs\fgms-0-x\src\server\fg_server.cxx	Fri Aug 12 18:21:09 2011
+++ C:\Projects\fgms2\fgms-0-x\src\server\fg_server.cxx	Sun Aug 14 16:21:33 2011
@@ -22,18 +22,23 @@
 //      (c) 2007-2010 Anders Gidenstam ( LazyRelay )
 //
 //////////////////////////////////////////////////////////////////////
-
+#include "config.h"
 
 #include <sys/types.h>
+#ifndef _MSC_VER
 #include <endian.h>
+#endif
 #include <unistd.h>
 #include <time.h>
 #include <string.h>
 #include <string>
+#ifndef _MSC_VER
 #include <sys/ipc.h>
 #include <sys/msg.h>
 
 #include <netinet/in.h>
+#endif
+
 /* From netSocket.cxx */
 #ifndef INADDR_NONE
   #define INADDR_NONE ((unsigned long)-1)
@@ -50,8 +55,13 @@
 #   define HIGH 1
 #endif
 
-bool    RunAsDaemon = true;
+bool    RunAsDaemon = false;
+#ifdef _MSC_VER
+#include <conio.h> // for _kbhit(), _getch
+typedef int pid_t;
+#else
 cDaemon Myself;
+#endif
 
 //////////////////////////////////////////////////////////////////////
 //
@@ -96,6 +106,16 @@
   m_BlackList           = map<uint32_t, bool>();
   m_RelayMap            = map<uint32_t, string>();
   m_MaxTracker          = 0;
+  // clear stats
+  m_PacketsReceived     = 0;
+  m_TelnetReceived      = 0;
+  m_BlackRejected       = 0;  // in black list
+  m_PacketsInvalid      = 0; // invalid packet
+  m_UnknownRelay        = 0; // unknown relay
+  m_PositionData        = 0;   // position data packet
+  m_ClientIgnored       = 0;  // no valid position data
+  m_ClientIgnored2      = 0; // known, but different IP
+
 } // FG_SERVER::FG_SERVER()
 //////////////////////////////////////////////////////////////////////
 
@@ -266,10 +286,209 @@
   m_BlackList.clear ();
   m_RelayMap.clear ();
   m_CrossfeedList.clear ();
+#ifndef _MSC_VER
   Myself.KillAllChildren ();
+#endif
 } // FG_SERVER::PrepareInit ()
 //////////////////////////////////////////////////////////////////////
 
+
+#ifdef _MSC_VER
+#include <vector>
+
+typedef std::vector<string> STG_LIST;
+typedef STG_LIST::iterator STG_LIST_I;
+
+static STG_LIST msg_list;
+static netSocket* pNewTelnet = 0;
+
+DWORD WINAPI TelnetSend( LPVOID vp )
+{
+    string Message;
+    int res = 0;
+    STG_LIST_I i = msg_list.begin();
+    int count = 0;
+    for ( ; i != msg_list.end(); i++ )
+    {
+        Message = *i;
+        res = pNewTelnet->send (Message.c_str(), Message.size(), 0);
+        if ( res == SOCKET_ERROR ) {
+            res = WSAGetLastError();
+            switch (res)
+            {
+            case WSANOTINITIALISED:
+                Message = "Not initialised";
+                break;
+            case WSAENETDOWN:
+                Message = "subsystem has failed.";
+                break;
+            case WSAEACCES:
+                Message = "broadcast, but flag not set.";
+                break;
+            case WSAEINTR:
+                Message = "call was canceled through WSACancelBlockingCall.";
+                break;
+            case WSAEINPROGRESS:
+                Message = "still processing a callback function.";
+                break;
+            case WSAEFAULT:
+                Message = "buf not completely in user address space.";
+                break;
+            case WSAENETRESET:
+                Message = "connection broken.";
+                break;
+            case WSAENOBUFS:
+                Message = "No buffer space is available.";
+                break;
+            case WSAENOTCONN:
+                Message = "is not connected.";
+                break;
+            case WSAENOTSOCK:
+                Message = "descriptor is not a socket.";
+                break;
+            case WSAEOPNOTSUPP:
+                Message = "Not supprted.";
+                break;
+            case WSAESHUTDOWN:
+                Message = "shut down.";
+                break;
+            case WSAEWOULDBLOCK:
+                Message = "would block.";
+                break;
+            case WSAEMSGSIZE:
+                Message = "message size.";
+                break;
+            case WSAEHOSTUNREACH:
+                Message = "host cannot be reached from this host at this time.";
+                break;
+            case WSAEINVAL:
+                Message = "bound with bind, or an unknown flag.";
+                break;
+            case WSAECONNABORTED:
+                Message = "circuit was terminated.";
+                break;
+            case WSAECONNRESET:
+                Message = "circuit was reset by the remote side.";
+                break;
+            case WSAETIMEDOUT:
+                Message = "connection has been dropped.";
+                break;
+            default:
+                Message = "Uncased error";
+                break;
+            }
+            SG_LOG (SG_SYSTEMS, SG_ALERT,
+                "TelnetSend: - " << Message << ", handle " << pNewTelnet->getHandle() );
+            break;
+        }
+        count++;
+    }
+    if ( res != SOCKET_ERROR ) {
+        SG_LOG (SG_SYSTEMS, SG_ALERT,
+            "TelnetSend: - Sent " << count << " messages, handle " << pNewTelnet->getHandle() <<
+            ( vp ? ", direct" : ", on thread" ));
+    }
+    pNewTelnet->close ();
+    delete pNewTelnet;
+    pNewTelnet = 0;
+    return 0xdead;
+}
+
+void FG_SERVER::TelnetReply(netSocket* NewTelnet)
+{
+    DWORD                   dwd;
+    string                  Message;
+    mT_PlayerListIt         CurrentPlayer;
+    Point3D                 PlayerPosGeod;  // Geodetic Coordinates
+
+    msg_list.clear(); // clear the list
+    //////////////////////////////////////////////////
+    //
+    //      create the output message
+    //      header
+    //
+    //////////////////////////////////////////////////
+    Message  = "# This is " + m_ServerName;
+    Message += "\n";
+    Message += "# FlightGear Multiplayer Server v" + string(VERSION);
+    Message += " using protocol version v";
+    Message += NumToStr (m_ProtoMajorVersion, 0);
+    Message += "." + NumToStr (m_ProtoMinorVersion, 0);
+    Message += "\n";
+    msg_list.push_back(Message); // 1
+    // NewTelnet->send (Message.c_str(), Message.size(), 0);
+    Message  = "# "+ NumToStr (m_PlayerList.size(), 0);
+    Message += " pilots(s) online\n";
+    msg_list.push_back(Message); // 2
+    //NewTelnet->send (Message.c_str(), Message.size(), 0);
+    //////////////////////////////////////////////////
+    //
+    //      create list of players
+    //
+    //////////////////////////////////////////////////
+    for (CurrentPlayer = m_PlayerList.begin();
+             CurrentPlayer != m_PlayerList.end();
+             CurrentPlayer++)
+    {
+            sgCartToGeod (CurrentPlayer->LastPos, PlayerPosGeod);
+            Message = CurrentPlayer->Callsign + "@";
+            if (CurrentPlayer->IsLocal)
+            {
+                    Message += "LOCAL: ";
+            }
+            else
+            {
+                    Message += CurrentPlayer->Origin + ": ";
+            }
+            if (CurrentPlayer->Error != "")
+            {
+                    Message += CurrentPlayer->Error + " ";
+            }
+            Message += NumToStr (CurrentPlayer->LastPos[X], 6)+" ";
+            Message += NumToStr (CurrentPlayer->LastPos[Y], 6)+" ";
+            Message += NumToStr (CurrentPlayer->LastPos[Z], 6)+" ";
+            Message += NumToStr (PlayerPosGeod[Lat], 6)+" ";
+            Message += NumToStr (PlayerPosGeod[Lon], 6)+" ";
+            Message += NumToStr (PlayerPosGeod[Alt], 6)+" ";
+            Message += NumToStr (CurrentPlayer->LastOrientation[X], 6)+" ";
+            Message += NumToStr (CurrentPlayer->LastOrientation[Y], 6)+" ";
+            Message += NumToStr (CurrentPlayer->LastOrientation[Z], 6)+" ";
+            Message += CurrentPlayer->ModelName;
+            Message += "\n";
+            msg_list.push_back(Message); // 3++
+            //NewTelnet->send (Message.c_str(), Message.size(), 0);
+    }
+    HANDLE hand = CreateThread(
+            0,  // __in_opt   LPSECURITY_ATTRIBUTES lpThreadAttributes,
+            0,  // __in       SIZE_T dwStackSize,
+            &TelnetSend, // __in       LPTHREAD_START_ROUTINE lpStartAddress,
+            0, // __in_opt   LPVOID lpParameter,
+            0,  // __in       DWORD dwCreationFlags,
+            &dwd );    // __out_opt  LPDWORD lpThreadId
+    if (hand) {
+        CloseHandle (hand);
+    } else {
+        TelnetSend( (LPVOID)1 );
+    }
+}
+
+#if 0   // failed attempt
+    // UGH! Could NOT get this right
+    //LPTHREAD_START_ROUTINE start = (LPTHREAD_START_ROUTINE)&FG_SERVER::TelnetReply;
+    //LPTHREAD_START_ROUTINE start = dynamic_cast<LPTHREAD_START_ROUTINE>(&FG_SERVER::TelnetReply);
+    void * start = (void *)&FG_SERVER::TelnetReply;
+    HANDLE hand = CreateThread(
+        0,  // __in_opt   LPSECURITY_ATTRIBUTES lpThreadAttributes,
+        0,  // __in       SIZE_T dwStackSize,
+        start, // __in       LPTHREAD_START_ROUTINE lpStartAddress,
+        &NewTelnet, // __in_opt   LPVOID lpParameter,
+        0,  // __in       DWORD dwCreationFlags,
+        (LPDWORD)&pid );    // __out_opt  LPDWORD lpThreadId
+#endif // 0 - failed attempt
+
+#endif // _MSC_VER
+
+
 //////////////////////////////////////////////////////////////////////
 //
 //      handle a telnet session
@@ -280,8 +499,10 @@
 void
 FG_SERVER::HandleTelnet ( netSocket* Telnet )
 {
+#ifndef _MSC_VER
   pid_t           Pid;
   netSocket       NewTelnet;
+#endif
   int             Fd;
   string          Message;
   Point3D         PlayerPosGeod;  // Geodetic Coordinates
@@ -299,6 +520,11 @@
     }
     return;
   }
+#ifdef _MSC_VER
+  pNewTelnet = new netSocket;
+  pNewTelnet->setHandle( Fd );
+  TelnetReply( pNewTelnet );
+#else
   NewTelnet.setHandle (Fd);
   //////////////////////////////////////////////////
   //
@@ -397,6 +623,8 @@
   }
   NewTelnet.close ();
   exit (0);
+#endif // _MSC_VER
+
 } // FG_SERVER::HandleTelnet ( netAddress& Sender )
 //////////////////////////////////////////////////////////////////////
 
@@ -633,6 +861,7 @@
 FG_SERVER::AddTracker ( const string & Server, int Port, bool IsTracked )
 {
   m_IsTracked     = IsTracked;
+#ifndef NO_TRACKER_PORT
   if ( m_Tracker )
   {
     msgctl(m_ipcid,IPC_RMID,NULL);
@@ -640,6 +869,7 @@
   }
   m_ipcid         = msgget(IPCKEY,IPCPERMS|IPC_CREAT);
   m_Tracker = new FG_TRACKER(Port,Server,m_ipcid);
+#endif // NO_TRACKER_PORT
   return (SUCCESS);
 } // FG_SERVER::AddTracker()
 //////////////////////////////////////////////////////////////////////
@@ -653,7 +883,7 @@
 FG_SERVER::MaxTracker ( const int MaxTracker )
 {
   m_MaxTracker = MaxTracker;
-} // FG_SERVER::AddTracker()
+} // FG_SERVER::MaxTracker()
 //////////////////////////////////////////////////////////////////////
 
 //////////////////////////////////////////////////////////////////////
@@ -1056,16 +1286,20 @@
   PacketFromLocalClient = true;  // assume client to be local
   if (true == IsBlackListed (SenderAddress))
   {
+    m_BlackRejected++;
     return;
   }
   if (false == PacketIsValid (Bytes, MsgHdr, SenderAddress))
   {
+    m_PacketsInvalid++;
     return;
   }
   if (MsgMagic == RELAY_MAGIC) // not a local client
   {
-    if (false == IsKnownRelay (SenderAddress))
-      return;
+      if (false == IsKnownRelay (SenderAddress)) {
+          m_UnknownRelay++;
+          return;
+      }
     PacketFromLocalClient = false;
     MsgHdr->Magic = XDR_encode<uint32_t> (MSG_MAGIC);
   }
@@ -1076,6 +1310,7 @@
   //////////////////////////////////////////////////
   if (MsgId == POS_DATA_ID)
   {
+    m_PositionData++;
     PosMsg = (T_PositionMsg *) (Msg + sizeof(T_MsgHdr));
     SenderPosition.Set (
       XDR_decode64<double> (PosMsg->position[X]),
@@ -1098,12 +1333,14 @@
     if (MsgId != POS_DATA_ID)
     {
       // ignore clients until we have a valid position
+      m_ClientIgnored++;
       return;
     }
     AddClient (SenderAddress, Msg, PacketFromLocalClient);
   }
   else if (ClientInList == 2)
   { // known, but different IP => ignore
+    m_ClientIgnored2++; // known, but different IP
     return;
   }
   //////////////////////////////////////////
@@ -1259,6 +1496,85 @@
 } // FG_SERVER::HandlePacket ( char* sMsg[MAX_PACKET_SIZE] )
 //////////////////////////////////////////////////////////////////////
 
+extern void SigHUPHandler ( int SigType );
+
+static char * exit_file = (char *)"fgms_exit";
+static char * reset_file = (char *)"fgms_reset";
+static char * stat_file = (char *)"fgms_stat";
+
+int
+FG_SERVER::check_keyboard()
+{
+    struct stat buf;
+    if (stat(exit_file,&buf) == 0) {
+        printf("Got EXIT file %s...\n",exit_file);
+        unlink(exit_file);
+        if (stat(exit_file,&buf) == 0) {
+            printf("ERROR: Unable to delete EXIT file %s...\n",exit_file);
+            exit(1);
+        }
+        return 1;
+    } else if ( stat(reset_file,&buf) == 0) {
+        printf("Got RESET file %s...\n",reset_file);
+        unlink(reset_file);
+        if (stat(reset_file,&buf) == 0) {
+            printf("ERROR: Unable to delete RESET file %s...\n",reset_file);
+            exit(1);
+        }
+        m_Initialized         = true; // Init() will do it
+        m_ReinitData          = true; // init the data port
+        m_ReinitTelnet        = true; // init the telnet port
+        m_Listening           = false;
+        SigHUPHandler ( 0 );
+    } else if ( stat(stat_file,&buf) == 0) {
+        printf("Got STAT file %s...\n",stat_file);
+        unlink(stat_file);
+        if (stat(stat_file,&buf) == 0) {
+            printf("ERROR: Unable to delete STAT file %s...\n",stat_file);
+            exit(1);
+        }
+        printf("Pilots %d Packets=%d, BL=%d INV=%d UR=%d PD=%d IG1=%d IG2=%d Telnet: %d\n", m_PacketsReceived,
+            m_PlayerList.size(),    // active pilots
+            m_BlackRejected,        // in black list
+            m_PacketsInvalid,       // invalid packet
+            m_UnknownRelay,         // unknown relay
+            m_PositionData,         // position data packet
+            m_ClientIgnored,        // no valid position data
+            m_ClientIgnored2,       // known, but different IP
+            m_TelnetReceived );     // telnet queries
+    }
+#ifdef _MSC_VER
+    if (_kbhit()) {
+        int ch = _getch ();
+        if ( ch == 0x1b ) {
+            printf("Got ESC key to exit...\n");
+            return 1;
+        } else if ( ch == 'R' ) {
+            printf("Got 'R' - Reset key...\n");
+            m_Initialized         = true; // Init() will do it
+            m_ReinitData          = true; // init the data port
+            m_ReinitTelnet        = true; // init the telnet port
+            m_Listening           = false;
+            SigHUPHandler ( 0 );
+        } else if ( ch == 'S' ) {
+            printf("Show stats\n");
+            printf("Pilots %d Packets=%d, BL=%d INV=%d UR=%d PD=%d IG1=%d IG2=%d Telnet: %d\n", m_PacketsReceived,
+                m_PlayerList.size(),    // active pilots
+                m_BlackRejected,        // in black list
+                m_PacketsInvalid,       // invalid packet
+                m_UnknownRelay,         // unknown relay
+                m_PositionData,         // position data packet
+                m_ClientIgnored,        // no valid position data
+                m_ClientIgnored2,       // known, but different IP
+                m_TelnetReceived );     // telnet queries
+        } else {
+            printf("Got UNKNOWN keyboard! %#X - Only ESC, to exit.\n", ch);
+        }
+    }
+#endif
+    return 0;
+}
+
 //////////////////////////////////////////////////////////////////////
 //
 //      main loop of the server
@@ -1283,6 +1599,11 @@
       << "not listening on any socket!");
     return (ERROR_NOT_LISTENING);
   }
+
+  SG_ALERT (SG_SYSTEMS, SG_ALERT,  "Entering infinite loop. Select timeout " << m_PlayerExpires << " secs.");
+#ifdef _MSC_VER
+  SG_ALERT (SG_SYSTEMS, SG_ALERT,  "ESC key to EXIT (after select timeout)." );
+#endif
   //////////////////////////////////////////////////
   //
   //      infinite listening loop
@@ -1305,6 +1626,8 @@
         // regularly (tracker)
         UpdateTracker (string(""),string(""), string(""),tick0,UPDATE);
       }
+      if (check_keyboard())
+          break;
     } // position (tracker)
     errno = 0;
     ListenSockets[0] = m_DataSocket;
@@ -1317,7 +1640,7 @@
       LastCleanUp = CurrentTime;
       continue;
     }
-    if (! Bytes)
+    if ( Bytes <= 0 )
     {
       SG_ALERT (SG_SYSTEMS, SG_ALERT, "FG_SERVER::Loop() - Bytes <= 0!");
       continue;
@@ -1334,10 +1657,12 @@
         // FIXME: reason to quit?
         continue;
       }
+      m_PacketsReceived++;
       HandlePacket ((char*)&Msg,Bytes,SenderAddress);
     } // DataSocket
     else if (ListenSockets[1] != 0)
     { // something on the wire (telnet)
+      m_TelnetReceived++;
       HandleTelnet (m_TelnetSocket);
       CleanUp ();
       LastCleanUp = CurrentTime;
@@ -1350,6 +1675,7 @@
       LastCleanUp = CurrentTime;
     }
   }
+  return (0);
 } // FG_SERVER::Loop()
 //////////////////////////////////////////////////////////////////////
 
@@ -1490,7 +1816,9 @@
   if (m_IsParent)
   {
     SG_LOG (SG_SYSTEMS, SG_ALERT, "FG_SERVER::Done() - exiting");
+#ifndef _MSC_VER
     Myself.KillAllChildren ();
+#endif
     m_LogFile.close();
     if (m_Listening == false)
     {
@@ -1590,7 +1918,9 @@
     // queue the message
     sprintf (buf.mtext, "%s", Message.c_str());
     buf.mtype = 1;
+#ifndef NO_TRACKER_PORT
     msgsnd (m_ipcid, &buf, strlen(buf.mtext), IPC_NOWAIT);
+#endif // NO_TRACKER_PORT
     return (0);
   }
   else if (type == DISCONNECT)
@@ -1606,7 +1936,9 @@
     // queue the message
     sprintf (buf.mtext, "%s", Message.c_str());
     buf.mtype = 1;
+#ifndef NO_TRACKER_PORT
     msgsnd (m_ipcid, &buf, strlen(buf.mtext), IPC_NOWAIT);
+#endif // NO_TRACKER_PORT
     return (0);
   }
   // we only arrive here if type!=CONNECT and !=DISCONNECT
@@ -1632,7 +1964,9 @@
       // queue the message
       sprintf(buf.mtext,"%s",Message.c_str());
       buf.mtype=1;
+#ifndef NO_TRACKER_PORT
       msgsnd(m_ipcid,&buf,strlen(buf.mtext),IPC_NOWAIT);
+#endif // NO_TRACKER_PORT
     }
     Message.erase(0);
     CurrentPlayer++;
diff -ur C:\fgcvs\fgms-0-x\src\server\fg_server.hxx C:\Projects\fgms2\fgms-0-x\src\server\fg_server.hxx
--- C:\fgcvs\fgms-0-x\src\server\fg_server.hxx	Fri Aug 12 18:21:09 2011
+++ C:\Projects\fgms2\fgms-0-x\src\server\fg_server.hxx	Sun Aug 14 16:20:49 2011
@@ -22,11 +22,9 @@
 //
 //////////////////////////////////////////////////////////////////////
 
-#if not defined FG_SERVER_HXX
+#if !defined FG_SERVER_HXX
 #define FG_SERVER_HXX
 
-using namespace std;
-
 #include <iostream>
 #include <fstream>
 #include <list>
@@ -52,6 +50,8 @@
 #include <arpa/inet.h>
 #endif
 
+using namespace std;
+
 //////////////////////////////////////////////////////////////////////
 //
 //  the server class
@@ -115,6 +115,10 @@
   void  MaxTracker ( const int MaxTracker );
   void  AddBlacklist  ( const string& FourDottedIP );
   void  CloseTracker ();
+#ifdef _MSC_VER
+  void  TelnetReply(netSocket* NewTelnet);
+#endif
+  int   check_keyboard();
 
 private:
 
@@ -220,6 +224,19 @@
   FG_TRACKER*       m_Tracker;
   mT_BlackList      m_BlackList;
   bool              m_IamHUB;
+  //////////////////////////////////////////////////
+  //
+  //  statistics
+  //
+  //////////////////////////////////////////////////
+  int               m_PacketsReceived; // rw data packet received
+  int               m_BlackRejected;  // in black list
+  int               m_PacketsInvalid; // invalid packet
+  int               m_UnknownRelay; // unknown relay
+  int               m_PositionData;   // position data packet
+  int               m_ClientIgnored;  // no valid position data
+  int               m_ClientIgnored2; // known, but different IP
+  int               m_TelnetReceived;
   //////////////////////////////////////////////////
   //
   //  private methods
diff -ur C:\fgcvs\fgms-0-x\src\server\fg_tracker.cxx C:\Projects\fgms2\fgms-0-x\src\server\fg_tracker.cxx
--- C:\fgcvs\fgms-0-x\src\server\fg_tracker.cxx	Mon Jan 31 18:54:49 2011
+++ C:\Projects\fgms2\fgms-0-x\src\server\fg_tracker.cxx	Sat Aug 13 12:49:28 2011
@@ -6,12 +6,14 @@
 //  Licenced under GPL
 //
 //////////////////////////////////////////////////////////////////////
+#include "config.h"
 
 #include <iostream>
 #include <fstream>
 #include <list>
 #include <string>
 #include <string.h>
+#ifndef _MSC_VER
 #include <errno.h>
 #include <time.h>
 #include <stdint.h>
@@ -20,6 +22,7 @@
 #include <sys/msg.h>
 #include <sys/types.h>
 #include <endian.h>
+#endif
 #include <unistd.h>
 #include "common.h"
 #include "fg_tracker.hxx"
@@ -29,7 +32,11 @@
 
 #define MAXLINE 4096
 
+#ifdef _MSC_VER
+typedef int pid_t;
+#else
 extern  cDaemon Myself;
+#endif // !_MSC_VER
 
 //////////////////////////////////////////////////////////////////////
 //
@@ -63,6 +70,7 @@
 int
 FG_TRACKER::InitTracker ( const int MaxChildren )
 {
+#ifndef NO_TRACKER_PORT
   int i;
   pid_t ChildsPID;
 
@@ -75,16 +83,28 @@
         TrackerLoop ();
         exit (0);
       }
+#ifndef _MSC_VER
       if (ChildsPID > 0)
       {
           Myself.AddChild (ChildsPID);
           SG_LOG (SG_SYSTEMS, SG_ALERT, "FG_TRACKER PID:" << ChildsPID);
       }
+#endif // _MSC_VER
   }
+#endif // NO_TRACKER_PORT
   return (0);
 } // InitTracker (int port, string server, int id, int pid)
 //////////////////////////////////////////////////////////////////////
 
+#ifdef _MSC_VER
+#define SWRITE(a,b,c) send(a,b,c,0)
+#define SREAD(a,b,c)  recv(a,b,c,0)
+#define SCLOSE closesocket
+#else
+#define SWRITE write
+#define SREAD  read
+#define SCLOSE close
+#endif
 //////////////////////////////////////////////////////////////////////
 //
 //  send the messages to the tracker server
@@ -107,21 +127,23 @@
     // get message from queue
     if (sent)
     {
+#ifndef NO_TRACKER_PORT
       length = msgrcv (ipcid, &buf, MAXLINE, 0, MSG_NOERROR);
+#endif // NO_TRACKER_PORT
       buf.mtext[length] = '\0';
       sent = false;
     }
     if ( length > 0 )
     {
       // send message via tcp
-      if (write (m_TrackerSocket,buf.mtext,strlen(buf.mtext)) < 0)
+      if (SWRITE (m_TrackerSocket,buf.mtext,strlen(buf.mtext)) < 0)
       {
         SG_LOG (SG_SYSTEMS, SG_ALERT, "FG_TRACKER::TrackerLoop: can't write to server...");
         Connect ();
       }
       sleep (1);
       // receive answer from server
-      if ( read (m_TrackerSocket,res,MAXLINE) <= 0 )
+      if ( SREAD (m_TrackerSocket,res,MAXLINE) <= 0 )
       {
         SG_LOG (SG_SYSTEMS, SG_ALERT, "FG_TRACKER::TrackerLoop: can't read from server...");
         Connect ();
@@ -159,7 +181,7 @@
   bool connected = false;
 
   if ( m_TrackerSocket > 0 )
-    close (m_TrackerSocket);
+    SCLOSE (m_TrackerSocket);
   while (connected == false)
   {
     m_TrackerSocket = TcpConnect (m_TrackerServer, m_TrackerPort);
@@ -175,7 +197,7 @@
     }
   }
   sleep (5);
-  write(m_TrackerSocket,"REPLY",sizeof("REPLY"));
+  SWRITE(m_TrackerSocket,"REPLY",sizeof("REPLY"));
   sleep (2);
   return (0);
 } // Connect ()
@@ -190,10 +212,27 @@
 FG_TRACKER::Disconnect ()
 {
   if ( m_TrackerSocket > 0 )
-    close (m_TrackerSocket);
+    SCLOSE (m_TrackerSocket);
 } // Disconnect ()
 //////////////////////////////////////////////////////////////////////
-
+#ifdef _MSC_VER
+#ifndef EAFNOSUPPORT
+#define	EAFNOSUPPORT	97	/* not present in errno.h provided with VC */
+#endif
+int inet_aton(const char *cp, struct in_addr *addr)
+{
+  addr->s_addr = inet_addr(cp);
+  return (addr->s_addr == INADDR_NONE) ? -1 : 0;
+}
+int inet_pton(int af, const char *src, void *dst)
+{
+    if (af != AF_INET) {
+        errno = EAFNOSUPPORT;
+        return -1;
+    }
+    return inet_aton (src, (struct in_addr *)dst);
+}
+#endif // _MSC_VER
 //////////////////////////////////////////////////////////////////////
 //
 //  creates a TCP connection
@@ -209,7 +248,12 @@
     bzero(&serveraddr,sizeof(serveraddr));
     serveraddr.sin_family = AF_INET;
     serveraddr.sin_port = htons(server_port);
+#ifdef _MSC_VER
+    if ( inet_pton(AF_INET, server_address, &serveraddr.sin_addr) == -1 )
+        return -1;
+#else
     inet_pton(AF_INET, server_address, &serveraddr.sin_addr);
+#endif
     if (connect(sockfd, (SA *) &serveraddr, sizeof(serveraddr))<0 )
         return -1;
     else
diff -ur C:\fgcvs\fgms-0-x\src\server\fg_tracker.hxx C:\Projects\fgms2\fgms-0-x\src\server\fg_tracker.hxx
--- C:\fgcvs\fgms-0-x\src\server\fg_tracker.hxx	Mon Jan 31 18:54:49 2011
+++ C:\Projects\fgms2\fgms-0-x\src\server\fg_tracker.hxx	Fri Aug 12 18:43:06 2011
@@ -7,7 +7,7 @@
 //
 //////////////////////////////////////////////////////////////////////
 
-#if not defined FG_TRACKER_HPP
+#if !defined FG_TRACKER_HPP
 #define FG_TRACKER_HPP
 
 using namespace std;
diff -ur C:\fgcvs\fgms-0-x\src\server\main.cxx C:\Projects\fgms2\fgms-0-x\src\server\main.cxx
--- C:\fgcvs\fgms-0-x\src\server\main.cxx	Mon Jan 31 18:54:49 2011
+++ C:\Projects\fgms2\fgms-0-x\src\server\main.cxx	Sat Aug 13 14:01:14 2011
@@ -21,20 +21,25 @@
 // main program
 //
 //////////////////////////////////////////////////////////////////////
-
-using namespace std;
+#include "config.h"
 
 #include <cstdlib>
+#ifndef _MSC_VER
 #include <sys/wait.h>
+#endif
 #include <signal.h>
 #include "fg_server.hxx"
 #include "fg_config.hxx"
 #include "daemon.hxx"
 #include "typcnvt.hxx"
 
+using namespace std;
+
 FG_SERVER       Servant;
 extern  bool    RunAsDaemon;
+#ifndef _MSC_VER
 extern  cDaemon Myself;
+#endif
 string          ConfigFileName; // from commandline
 
 //////////////////////////////////////////////////////////////////////
@@ -66,6 +71,42 @@
   exit (0);
 } // PrintHelp ()
 //////////////////////////////////////////////////////////////////////
+#ifdef _MSC_VER
+// kludge for getopt() for WIN32
+static char * optarg;
+static int curr_arg = 0;
+int getopt ( int argcount, char* argvars[], char * args )
+{
+    size_t len = strlen(args);
+    size_t i;
+    int c = 0;
+    if (curr_arg == 0) {
+        curr_arg = 1;
+    }
+    if (curr_arg < argcount) {
+        char * arg = argvars[curr_arg];
+        if (*arg == '-') {
+            arg++;
+            c = *arg; // get first char
+            for (i = 0; i < len; i++) {
+                if (c == args[i]) { // found 
+                    if ( args[i+1] == ':' ) {
+                        // fill in following
+                        curr_arg++;
+                        optarg = argvars[curr_arg];
+                    }
+                    break;
+                }
+            }
+            curr_arg++;
+            return c;
+        } else {
+            return '-';
+        }
+    }
+    return -1;
+}
+#endif // _MSC_VER
 
 //////////////////////////////////////////////////////////////////////
 //
@@ -421,25 +462,37 @@
 //      read config files
 //
 //////////////////////////////////////////////////////////////////////
-void
+int
 ReadConfigs ( bool ReInit = false )
 {
   string Path;
-
+#ifndef _MSC_VER
   Path = SYSCONFDIR;
   Path += "/fgms.conf";
   if (ProcessConfig (ConfigFileName) == true)
-    return;
+    return 1;
   if (ProcessConfig (Path) == true)
-    return;
+    return 1;
   Path = getenv ("HOME");
+#else
+    char *cp = getenv("HOME");
+    if (cp)
+        Path = cp;
+    else {
+        cp = getenv("USERPROFILE");
+        if (cp)
+            Path = cp;
+    }
+#endif
   if (Path != "")
   {
     Path += "/fgms.conf";
     if (ProcessConfig (Path))
-        return;
+        return 1;
   }
-  ProcessConfig ("fgms.conf");
+  if (ProcessConfig ("fgms.conf"))
+      return 1;
+  return 0;
 } // ReadConfigs ()
 //////////////////////////////////////////////////////////////////////
 
@@ -451,16 +504,23 @@
 void SigHUPHandler ( int SigType )
 {
   Servant.PrepareInit();
-  ReadConfigs (true);
+  if ( !ReadConfigs (true) )
+  {
+    SG_ALERT (SG_SYSTEMS, SG_ALERT, "received HUP signal, but read config file failed!");
+    exit (1);
+  }
   if (Servant.Init () != 0)
   {
     SG_ALERT (SG_SYSTEMS, SG_ALERT, "received HUP signal, but reinit failed!");
     exit (1);
   }
+#ifndef _MSC_VER
   signal (SigType, SigHUPHandler);
+#endif
 } // SigHUPHandler ()
 //////////////////////////////////////////////////////////////////////
 
+#ifndef _MSC_VER
 //////////////////////////////////////////////////////////////////////
 //
 //  add the pid of the child to the main exit pon receiving SIGCHLD
@@ -473,6 +533,7 @@
     /* intentionally empty */ ;
 } // SigCHLDHandler ()
 //////////////////////////////////////////////////////////////////////
+#endif // !_MSC_VER
 
 //////////////////////////////////////////////////////////////////////
 //
@@ -483,11 +544,13 @@
 main ( int argc, char* argv[] )
 {
   int     I;
+#ifndef _MSC_VER
   struct  sigaction sig_child;
-
+#endif
 #if defined ENABLE_DEBUG
 //  logbuf::set_log_classes(SG_GENERAL);
 #endif
+#ifndef _MSC_VER
   // SIGHUP
   signal (SIGHUP, SigHUPHandler);
   // SIGCHLD
@@ -498,8 +561,12 @@
   {
     exit(1);
   }
+#endif
   ParseParams (argc, argv);
-  ReadConfigs ();
+  if (!ReadConfigs ()) {
+    printf("No configuration file 'fgms.conf' found!\n");
+    exit(1);
+  }
   sglog().setLogLevels( SG_ALL, SG_INFO );
   sglog().enable_with_date (true);
   I = Servant.Init ();
@@ -508,11 +575,13 @@
     Servant.CloseTracker();
     return (I);
   }
+#ifndef _MSC_VER
   if (RunAsDaemon)
   {
     SG_ALERT (SG_SYSTEMS, SG_ALERT, "Main server started!");
     Myself.Daemonize ();
   }
+#endif
   I = Servant.Loop();
   if (I != 0)
   {
diff -ur C:\fgcvs\fgms-0-x\src\simgear\debug\logstream.cxx C:\Projects\fgms2\fgms-0-x\src\simgear\debug\logstream.cxx
--- C:\fgcvs\fgms-0-x\src\simgear\debug\logstream.cxx	Mon Jan 31 18:54:49 2011
+++ C:\Projects\fgms2\fgms-0-x\src\simgear\debug\logstream.cxx	Fri Aug 12 18:34:05 2011
@@ -19,7 +19,7 @@
 // Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 //
 // $Id: logstream.cxx,v 1.2 2010/02/15 08:04:17 oliver Exp $
-
+#include "config.h"
 #include "logstream.hxx"
 #include "stdio.h"
 
@@ -98,7 +98,9 @@
 
     if (userdatestr)
     {
-            return (*userdatestr)()+" ";
+        string msg = (*userdatestr)();
+        msg += " ";
+            return msg;
     }
     date = time(0);
     tmr = localtime(&date);
Only in C:\Projects\fgms2\fgms-0-x: temp
